{
  "version": 3,
  "sources": ["../../../../../node_modules/ccount/index.js", "../../../../../node_modules/markdown-table/index.js", "../../../../../node_modules/zwitch/index.js"],
  "sourcesContent": ["/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n", "// To do: next major: remove.\n/**\n * @typedef {Options} MarkdownTableOptions\n *   Configuration.\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [alignDelimiters=true]\n *   Whether to align the delimiters (default: `true`);\n *   they are aligned by default:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   Pass `false` to make them staggered:\n *\n *   ```markdown\n *   | Alpha | B |\n *   | - | - |\n *   | C | Delta |\n *   ```\n * @property {ReadonlyArray<string | null | undefined> | string | null | undefined} [align]\n *   How to align columns (default: `''`);\n *   one style for all columns or styles for their respective columns;\n *   each style is either `'l'` (left), `'r'` (right), or `'c'` (center);\n *   other values are treated as `''`, which doesn‚Äôt place the colon in the\n *   alignment row but does align left;\n *   *only the lowercased first character is used, so `Right` is fine.*\n * @property {boolean | null | undefined} [delimiterEnd=true]\n *   Whether to end each row with the delimiter (default: `true`).\n *\n *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures\n *   > that aren‚Äôt understandable to some markdown parsers.\n *\n *   When `true`, there are ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no ending delimiters:\n *\n *   ```markdown\n *   | Alpha | B\n *   | ----- | -----\n *   | C     | Delta\n *   ```\n * @property {boolean | null | undefined} [delimiterStart=true]\n *   Whether to begin each row with the delimiter (default: `true`).\n *\n *   > üëâ **Note**: please don‚Äôt use this: it could create fragile structures\n *   > that aren‚Äôt understandable to some markdown parsers.\n *\n *   When `true`, there are starting delimiters:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there are no starting delimiters:\n *\n *   ```markdown\n *   Alpha | B     |\n *   ----- | ----- |\n *   C     | Delta |\n *   ```\n * @property {boolean | null | undefined} [padding=true]\n *   Whether to add a space of padding between delimiters and cells\n *   (default: `true`).\n *\n *   When `true`, there is padding:\n *\n *   ```markdown\n *   | Alpha | B     |\n *   | ----- | ----- |\n *   | C     | Delta |\n *   ```\n *\n *   When `false`, there is no padding:\n *\n *   ```markdown\n *   |Alpha|B    |\n *   |-----|-----|\n *   |C    |Delta|\n *   ```\n * @property {((value: string) => number) | null | undefined} [stringLength]\n *   Function to detect the length of table cell content (optional);\n *   this is used when aligning the delimiters (`|`) between table cells;\n *   full-width characters and emoji mess up delimiter alignment when viewing\n *   the markdown source;\n *   to fix this, you can pass this function,\n *   which receives the cell content and returns its ‚Äúvisible‚Äù size;\n *   note that what is and isn‚Äôt visible depends on where the text is displayed.\n *\n *   Without such a function, the following:\n *\n *   ```js\n *   markdownTable([\n *     ['Alpha', 'Bravo'],\n *     ['‰∏≠Êñá', 'Charlie'],\n *     ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']\n *   ])\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo |\n *   | - | - |\n *   | ‰∏≠Êñá | Charlie |\n *   | üë©‚Äç‚ù§Ô∏è‚Äçüë© | Delta |\n *   ```\n *\n *   With [`string-width`](https://github.com/sindresorhus/string-width):\n *\n *   ```js\n *   import stringWidth from 'string-width'\n *\n *   markdownTable(\n *     [\n *       ['Alpha', 'Bravo'],\n *       ['‰∏≠Êñá', 'Charlie'],\n *       ['üë©‚Äç‚ù§Ô∏è‚Äçüë©', 'Delta']\n *     ],\n *     {stringLength: stringWidth}\n *   )\n *   ```\n *\n *   Yields:\n *\n *   ```markdown\n *   | Alpha | Bravo   |\n *   | ----- | ------- |\n *   | ‰∏≠Êñá  | Charlie |\n *   | üë©‚Äç‚ù§Ô∏è‚Äçüë©    | Delta   |\n *   ```\n */\n\n/**\n * @param {string} value\n *   Cell value.\n * @returns {number}\n *   Cell size.\n */\nfunction defaultStringLength(value) {\n  return value.length\n}\n\n/**\n * Generate a markdown\n * ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables))\n * table.\n *\n * @param {ReadonlyArray<ReadonlyArray<string | null | undefined>>} table\n *   Table data (matrix of strings).\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Result.\n */\nexport function markdownTable(table, options) {\n  const settings = options || {}\n  // To do: next major: change to spread.\n  const align = (settings.align || []).concat()\n  const stringLength = settings.stringLength || defaultStringLength\n  /** @type {Array<number>} Character codes as symbols for alignment per column. */\n  const alignments = []\n  /** @type {Array<Array<string>>} Cells per row. */\n  const cellMatrix = []\n  /** @type {Array<Array<number>>} Sizes of each cell per row. */\n  const sizeMatrix = []\n  /** @type {Array<number>} */\n  const longestCellByColumn = []\n  let mostCellsPerRow = 0\n  let rowIndex = -1\n\n  // This is a superfluous loop if we don‚Äôt align delimiters, but otherwise we‚Äôd\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < table.length) {\n    /** @type {Array<string>} */\n    const row = []\n    /** @type {Array<number>} */\n    const sizes = []\n    let columnIndex = -1\n\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length\n    }\n\n    while (++columnIndex < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex])\n\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        if (\n          longestCellByColumn[columnIndex] === undefined ||\n          size > longestCellByColumn[columnIndex]\n        ) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  let columnIndex = -1\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    const code = toAlignment(align)\n\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  /** @type {Array<string>} */\n  const row = []\n  /** @type {Array<number>} */\n  const sizes = []\n\n  while (++columnIndex < mostCellsPerRow) {\n    const code = alignments[columnIndex]\n    let before = ''\n    let after = ''\n\n    if (code === 99 /* `c` */) {\n      before = ':'\n      after = ':'\n    } else if (code === 108 /* `l` */) {\n      before = ':'\n    } else if (code === 114 /* `r` */) {\n      after = ':'\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    let size =\n      settings.alignDelimiters === false\n        ? 1\n        : Math.max(\n            1,\n            longestCellByColumn[columnIndex] - before.length - after.length\n          )\n\n    const cell = before + '-'.repeat(size) + after\n\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (++rowIndex < cellMatrix.length) {\n    const row = cellMatrix[rowIndex]\n    const sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    /** @type {Array<string>} */\n    const line = []\n\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row[columnIndex] || ''\n      let before = ''\n      let after = ''\n\n      if (settings.alignDelimiters !== false) {\n        const size =\n          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        const code = alignments[columnIndex]\n\n        if (code === 114 /* `r` */) {\n          before = ' '.repeat(size)\n        } else if (code === 99 /* `c` */) {\n          if (size % 2) {\n            before = ' '.repeat(size / 2 + 0.5)\n            after = ' '.repeat(size / 2 - 0.5)\n          } else {\n            before = ' '.repeat(size / 2)\n            after = before\n          }\n        } else {\n          after = ' '.repeat(size)\n        }\n      }\n\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push('|')\n      }\n\n      if (\n        settings.padding !== false &&\n        // Don‚Äôt add the opening space if we‚Äôre not aligning and the cell is\n        // empty: there will be a closing space.\n        !(settings.alignDelimiters === false && cell === '') &&\n        (settings.delimiterStart !== false || columnIndex)\n      ) {\n        line.push(' ')\n      }\n\n      if (settings.alignDelimiters !== false) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (settings.alignDelimiters !== false) {\n        line.push(after)\n      }\n\n      if (settings.padding !== false) {\n        line.push(' ')\n      }\n\n      if (\n        settings.delimiterEnd !== false ||\n        columnIndex !== mostCellsPerRow - 1\n      ) {\n        line.push('|')\n      }\n    }\n\n    lines.push(\n      settings.delimiterEnd === false\n        ? line.join('').replace(/ +$/, '')\n        : line.join('')\n    )\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @param {string | null | undefined} [value]\n *   Value to serialize.\n * @returns {string}\n *   Result.\n */\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\n/**\n * @param {string | null | undefined} value\n *   Value.\n * @returns {number}\n *   Alignment.\n */\nfunction toAlignment(value) {\n  const code = typeof value === 'string' ? value.codePointAt(0) : 0\n\n  return code === 67 /* `C` */ || code === 99 /* `c` */\n    ? 99 /* `c` */\n    : code === 76 /* `L` */ || code === 108 /* `l` */\n      ? 108 /* `l` */\n      : code === 82 /* `R` */ || code === 114 /* `r` */\n        ? 114 /* `r` */\n        : 0\n}\n", "/**\n * @callback Handler\n *   Handle a value, with a certain ID field set to a certain value.\n *   The ID field is passed to `zwitch`, and it‚Äôs value is this function‚Äôs\n *   place on the `handlers` record.\n * @param {...any} parameters\n *   Arbitrary parameters passed to the zwitch.\n *   The first will be an object with a certain ID field set to a certain value.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback UnknownHandler\n *   Handle values that do have a certain ID field, but it‚Äôs set to a value\n *   that is not listed in the `handlers` record.\n * @param {unknown} value\n *   An object with a certain ID field set to an unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {any}\n *   Anything!\n */\n\n/**\n * @callback InvalidHandler\n *   Handle values that do not have a certain ID field.\n * @param {unknown} value\n *   Any unknown value.\n * @param {...any} rest\n *   Arbitrary parameters passed to the zwitch.\n * @returns {void|null|undefined|never}\n *   This should crash or return nothing.\n */\n\n/**\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @typedef Options\n *   Configuration (required).\n * @property {Invalid} [invalid]\n *   Handler to use for invalid values.\n * @property {Unknown} [unknown]\n *   Handler to use for unknown values.\n * @property {Handlers} [handlers]\n *   Handlers to use.\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Handle values based on a field.\n *\n * @template {InvalidHandler} [Invalid=InvalidHandler]\n * @template {UnknownHandler} [Unknown=UnknownHandler]\n * @template {Record<string, Handler>} [Handlers=Record<string, Handler>]\n * @param {string} key\n *   Field to switch on.\n * @param {Options<Invalid, Unknown, Handlers>} [options]\n *   Configuration (required).\n * @returns {{unknown: Unknown, invalid: Invalid, handlers: Handlers, (...parameters: Parameters<Handlers[keyof Handlers]>): ReturnType<Handlers[keyof Handlers]>, (...parameters: Parameters<Unknown>): ReturnType<Unknown>}}\n */\nexport function zwitch(key, options) {\n  const settings = options || {}\n\n  /**\n   * Handle one value.\n   *\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesn‚Äôt have a `key` property, the special\n   * ‚Äúinvalid‚Äù handler will be called.\n   * If `value` has an unknown `key`, the special ‚Äúunknown‚Äù handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and it‚Äôs result is returned.\n   *\n   * @this {unknown}\n   *   Any context object.\n   * @param {unknown} [value]\n   *   Any value.\n   * @param {...unknown} parameters\n   *   Arbitrary parameters passed to the zwitch.\n   * @property {Handler} invalid\n   *   Handle for values that do not have a certain ID field.\n   * @property {Handler} unknown\n   *   Handle values that do have a certain ID field, but it‚Äôs set to a value\n   *   that is not listed in the `handlers` record.\n   * @property {Handlers} handlers\n   *   Record of handlers.\n   * @returns {unknown}\n   *   Anything.\n   */\n  function one(value, ...parameters) {\n    /** @type {Handler|undefined} */\n    let fn = one.invalid\n    const handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      // @ts-expect-error Indexable.\n      const id = String(value[key])\n      // @ts-expect-error Indexable.\n      fn = own.call(handlers, id) ? handlers[id] : one.unknown\n    }\n\n    if (fn) {\n      return fn.call(this, value, ...parameters)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  // @ts-expect-error: matches!\n  return one\n}\n"],
  "mappings": "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",
  "names": ["row", "sizes", "columnIndex"]
}
